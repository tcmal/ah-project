# Test script for RSA

from rsa import RSAKeypair
import numpy as np
from math import ceil
import time

# Messages to test with
INPUT_MESSAGES = [
	list([i for i in range(0,16)]),
	list([ord(x) for x in "1234567890abcdef"]),
	list([i for i in range(0,128)])
]

# Key to use
# key = RSAKeypair(65537, 131466088182001108320256333478252604363294547508681577372622031679443521260479840537054285628717776274858896758171825995874177483336965912862194238289043458231635397678775189671061682659130198692129784878637245047098561349111627361836837736941706852772131820787733412829124264281335501664834323566363244998092109868024362048902595365837458839539585470562447873292224121316413080487107789352472694891018531748492017702003394819549484205154304593747073237731278793622535145134465111671648141861427780457563273581113169956067814134576161195161953569592587867683251486716902819266048936855923346527973534967412468800200551987881729856234709441978214776836616991886298038496161304823580151242709577425074126366727826258413417208412673443826634108865123194322963232842312217509013231096262280053097823959101844059541386547409017677497555523667364539555534278974998684741040686033229173651219162740065711387908887153895626070899325606058025688071697766936114603014764675271002815489525187311633869498274742730993138906793131012893412086099154605947147871188310748325163674820762190603192288616424881694280072456346971926011084413898369858089103054498690108817030716353239774503286960448638913866361655671536968652648167441380831155932516661, 165381749835572233256898464924357274548577360694022007721548843314887422555004459168031301557657387253112991474371018682296599990891121082427963679189762195944616562521333082624188907162243811192316442628006394392224089969417216392742400421635576751254913011094030072299409119684547762301250495490503253305180002772150269988654421415645613758314409908137726668943557061610337717255956834189934218958340816461618161585814854718867008586928185119304411746956539115450795358786061385945924031579023599206236909240175323327846446723184019737169682536237968233955069441329935698144596602006385173069539542798228515418522083091611665548634592067760553828274364496490355691350903292314069394707934755578702478676529544578097204544192667283343002984852183941194957523736149325400483104106184845035856233460006878466374877739996211399858369492852888111445961418521004111447995118654940772946941441916971773636858618683133686305676958732197484869387387785244596235278382500195324016115974001302726643776844170977780360542797283054850678439426136856869992621813655458856824457340167006163883025946774735611015541695420631626542554266053332523739850492551890232807910147484983022681338031569566341942767470087020319500678719364683685662074415313)

# Or generate a new one:
start = time.time()
key = RSAKeypair.generate_keypair()
print("Generated key in %s" % (time.time() - start))

# Hexdump bytearray
def xxd(arr):
    for i in range(0,ceil(len(arr) / 16)):
        print("\t".join([hex(x)[2:] for x in arr[i*16:(i+1)*16]]))

# Returns (True,) or (False, output) where output is invalid decryption
# output can be bytearray or False, see decrypt()
def test_encrypt_decrypt(msg, key):
	encrypted = key.encrypt(msg)
	decrypted = key.decrypt(encrypted)

	if decrypted == False or not np.array_equal(decrypted, msg):
		return (False, decrypted)
	
	signed = key.sign(msg)
	verified = key.decrypt_signed(signed)

	if decrypted == False or not np.array_equal(decrypted, msg):
		return (False, verified)

	return (True,)

# Tests serialisation/deserialisation with a full private key
# This also tests public key serialisation/deserialisation
# Returns false on failure
def test_serialisation(key):
	# Full private key test
	serialised = key.serialise()
	deserialised = RSAKeypair.deserialise(serialised)

	if key != deserialised:
		print(key, deserialised)
		return False

	pub_key = RSAKeypair(key.e, None, key.n)
	serialised = pub_key.serialise()
	other_serialised = key.serialise(force_public=True)
	deserialised = RSAKeypair.deserialise(serialised)

	return serialised == other_serialised and pub_key == deserialised

# Each entry = (expected, actual)
failures = []

# First test serialisation/deserialisation
if not test_serialisation(key):
	failures.append(("Correct serialisation then deserialisation", "Something different out the other end"))
	print("x", end="")
else:
	print(".", end="")

# For each message
for msg in INPUT_MESSAGES:
	# Run test with message
	res = test_encrypt_decrypt(msg, key)

	# If it failed, add it to failures
	if res[0] != True:
		failures.append((msg, res[1]))
		print("x", end="")
	else:
		print(".", end="")

print()
print("%s tests, %s failures" % (len(INPUT_MESSAGES) + 1 , len(failures)))
print("---")

# Print failures
for expected, actual in failures:
	print("Expected:")
	xxd(expected)

	print("Got:")
	if actual != False:
		xxd(actual)
	else:
		print("\tVerification error")

	print("---")